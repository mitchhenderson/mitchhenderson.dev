---
title: "Title"
description: |
  Subtitle here
author: Mitch Henderson
date: 2025-11-23
thumbnailImage: /img/nrl_finals_probs.png
draft: true
format:
  html:
    code-fold: true
    code-tools: true
    html-table-processing: none
knitr:
    opts_chunk:
      dev: "ragg_png"
---

Strength and conditioning coaches collect training data to monitor their athletes' progress and evaluate the effectiveness of their programming. A common method of achieving this in strength training is to calculate an **estimated one repetition maximum** (e1RM) for an exercise completed at a submaximal weight and track changes in this metric over time. Using e1RM is often preferred to true 1RM testing within a program or in-season because it doesn't impact training (integrates into existing training sessions), is safer (lower weight), and yields more frequent data points than periodic testing allows (enabling timely program adjustments). Coaches often program true 1RM testing only a handful of times per season (if at all) and rely on training data measures (e.g., e1RM) between these occasional tests to make inferences on progress and appropriate adjustments.

## The problem

There are a lot of different ways to calculate e1RM.

```{r}
#| warning: false

library(tidyverse)
library(gganimate)
library(scales)
mitchhenderson::font_hoist("Myriad Pro")

# Define the 1RM estimation formulas
# Each formula calculates %1RM based on number of reps
formulas <- list(
  Epley = function(reps) {
    # Epley: 1RM = weight × (1 + reps/30)
    # Therefore: %1RM = 100 / (1 + reps/30)
    100 / (1 + reps / 30)
  },

  Brzycki = function(reps) {
    # Brzycki: 1RM = weight × (36/(37 - reps))
    # Therefore: %1RM = 100 × (37 - reps) / 36
    100 * (37 - reps) / 36
  },

  Mayhew = function(reps) {
    # Mayhew: 1RM = (100 × weight) / (52.2 + 41.9 × exp(-0.055 × reps))
    # Therefore: %1RM = 52.2 + 41.9 × exp(-0.055 × reps)
    52.2 + 41.9 * exp(-0.055 * reps)
  },

  Lombardi = function(reps) {
    # Lombardi: 1RM = weight × reps^0.10
    # Therefore: %1RM = 100 / reps^0.10
    100 / (reps^0.10)
  },

  `O'Conner` = function(reps) {
    # O'Conner: 1RM = weight × (1 + reps/40)
    # Therefore: %1RM = 100 / (1 + reps/40)
    100 / (1 + reps / 40)
  },

  Wathan = function(reps) {
    # Wathan: 1RM = (100 × weight) / (48.8 + 53.8 × exp(-0.075 × reps))
    # Therefore: %1RM = 48.8 + 53.8 × exp(-0.075 × reps)
    48.8 + 53.8 * exp(-0.075 * reps)
  },

  Lander = function(reps) {
    # Lander: 1RM = (100 × weight) / (101.3 - 2.67123 × reps)
    # Therefore: %1RM = 101.3 - 2.67123 × reps
    101.3 - 2.67123 * reps
  }
)

# Generate data for reps 1 to 20
reps_range <- 1:20

# Create a tidy dataframe with all formulas
e1rm_data <- tibble(reps = reps_range) |>
  crossing(formula = names(formulas)) |>
  mutate(
    percent_1rm = map2_dbl(formula, reps, ~ formulas[[.x]](.y))
  )

e1rm_data_animated <- e1rm_data |>
  crossing(highlight = unique(e1rm_data$formula)) |>
  mutate(
    is_highlighted = formula == highlight,
    line_color = if_else(is_highlighted, "highlighted", "grey"),
    label = if_else(is_highlighted & reps == max(reps), formula, NA_character_),
    line_size = if_else(is_highlighted, 2, 1)
  )

animated_plot <- e1rm_data_animated |>
  ggplot(aes(x = reps, y = percent_1rm, group = formula)) +
  coord_cartesian(xlim = c(1, 20), clip = "off") +
  geom_line(
    data = e1rm_data_animated |> filter(!is_highlighted),
    aes(linewidth = line_size),
    colour = "grey70"
  ) +
  geom_line(
    data = e1rm_data_animated |> filter(is_highlighted),
    aes(linewidth = line_size),
    colour = "#E74C3C"
  ) +
  geom_text(
    aes(label = label),
    colour = "#E74C3C",
    family = "Myriad Pro Regular",
    hjust = 0,
    nudge_x = 0.5,
    size = 6,
    fontface = "bold",
    show.legend = FALSE
  ) +
  scale_linewidth_identity() +
  scale_x_continuous(
    breaks = seq(1, 20, 1)
  ) +
  scale_y_continuous(
    labels = label_percent(scale = 1),
    breaks = seq(40, 100, 10),
    limits = c(40, 100)
  ) +
  labs(
    title = "1RM Estimation Formulas",
    x = "Number of Repetitions",
    y = NULL,
    subtitle = "% of 1RM"
  ) +
  theme_classic(base_size = 16, base_family = "Myriad Pro Regular") +
  theme(
    plot.title = element_text(face = "bold"),
    plot.subtitle = element_text(size = 14, color = "grey40", face = "bold"),
    axis.title.x = element_text(size = 14, color = "grey40", face = "bold"),
    panel.grid = element_blank(),
    plot.margin = margin(10, 100, 10, 10),
    plot.caption = element_text(color = "grey50", hjust = 0, size = 10),
    legend.position = "none",
    ,
    plot.title.position = "plot"
  ) +
  transition_manual(
    highlight,
    cumulative = FALSE
  )

# Render the animation
animate(
  animated_plot,
  nframes = 80,
  fps = 10,
  width = 8,
  height = 4.5,
  device = "ragg_png"
)
```

But none of these common e1RM formulas:

-   Account for differences between athletes in strength endurance.

    Some athletes (fast twitch dominant, higher metabolic cost per rep) have relatively high 1RMs but find higher rep sets at moderate intensities challenging. Other athletes (greater oxidative capacity, lower metabolic cost per rep) can perform many reps at moderate intensities but quickly hit their 1RM ceiling with more weight. **I want my e1RM estimates to take into account what I know about the physiological characteristics of the athlete**. If a fast twitch dominant athlete does a max reps set of 14 x 100kg, I'd expect their 1RM to be higher than a more oxidative dominant athlete performing the same 14 x 100kg because I know they are better suited to high intensity efforts. The common e1RM formulas don't do this.

-   Capture the level of uncertainty in the e1RM they generate.

    The common e1RM formulas return a prediction as a single value. There's a big difference in how I'd interpret a 100kg e1RM if it has 80% certainty of being between 97.5–102.5kg (precise) compared to 80% certainty of being between 77.5–122.5kg (practically useless). There's also a big difference in the level of certainty we can expect from these models when the athlete does 2-5 reps (higher certainty) compared 10+ reps (lower certainty). We also become more certain about an athlete's capacity the more we work with them. I'd have a lot more certainty predicting the 1RM of an athlete I'd worked with and collected training data on for years compared to someone new from another team with limited training data available to me. **I want my e1RM estimates to incorporate all these sources of uncertainty into the prediction so I can interpret and act accordingly**.

## My solution

To address these shortcomings, I'll extend ......

I'll first simulate a dataset

```{r}
set.seed(2534)

# Define hyperparameters (the "truth" of the population)
n_athletes <- 30
n_obs_per_athlete <- 15
noise <- 2.5 # Measurement noise (std dev in kg)

# Population distributions
pop_mean_1rm <- 140
pop_sd_1rm <- 20
pop_mean_endurance_coefficient <- 30
pop_sd_endurance_coefficient <- 6

# Athlete-level parameters (the "truth" for each person)
athletes <- tibble(
  athlete_id = 1:n_athletes,
  # Latent Variable 1: True Strength
  true_one_rm = rnorm(n_athletes, mean = pop_mean_1rm, sd = pop_sd_1rm),
  # Latent Variable 2: True Endurance (The Beta Coefficient)
  true_beta = rnorm(
    n_athletes,
    mean = pop_mean_endurance_coefficient,
    sd = pop_sd_endurance_coefficient
    )
)

# 4. Generate Session Data (The Observations)
sim_data <- athletes |>
  # Create multiple observations per athlete
  expand_grid(session_id = 1:n_obs_per_athlete) |>
  mutate(
    # Simulate the Reps performed (Independent Variable)
    # We vary reps from 1 to 12 to ensure the model can learn the curve
    reps = sample(1:12, size = n(), replace = TRUE),

    # Calculate the Theoretical Weight (Deterministic Modified Epley)
    # Formula: W = 1RM / (1 + R/Beta)
    weight_theoretical = true_one_rm / (1 + reps / true_beta),

    # Add Noise to create Observed Weight (Dependent Variable)
    weight_observed = rnorm(n(), mean = weight_theoretical, sd = sigma_noise),

    # Clean up: Ensure no negative weights (unlikely but good practice)
    weight_observed = pmax(weight_observed, 0)
  )
    ```
